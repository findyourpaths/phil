package parse

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	"go/scanner"
	"go/token"

	"cloud.google.com/go/civil"
	"github.com/findyourpaths/phil/glr"
)

// datetimeLexer implements yyLexer interface for the parser generated by goyacc,
// and also GLR's Lexer interface.
type datetimeLexer struct {
	lval    *yySymType
	scanner scanner.Scanner
	err     error
	ast     *ast
}

// // ast is the abstract syntax tree for a label formula
type ast struct {
	root *datetime_ranges
}

// node represents a node in abstract syntax tree
type datetime_ranges struct {
	items []*datetime_range
}

// node represents a node in abstract syntax tree
type datetime_range struct {
	start *civil.DateTime
	end   *civil.DateTime
}

func NewDatetimeLexer(input string) *datetimeLexer {
	l := &datetimeLexer{
		lval: &yySymType{},
	}
	l.scanner = glr.NewLexerScanner(l, input)
	return l
}

func (l *datetimeLexer) NextToken(pos int) (string, any, bool) {
	val := l.Lex(l.lval)
	sym := l.lval.string
	if val >= 57343 {
		sym = yyToknames[val-57343]
	}
	fmt.Printf("sym: %q, l.lval.string: %q, val: %d\n", sym, l.lval.string, val)
	return sym, l.lval.string, val >= 0
}

func (l *datetimeLexer) Error(msg string) {
	l.err = errors.New(msg)
}

var months = []string{`jan`, `feb`, `mar`, `apr`, `may`, `jun`, `jul`, `aug`, `sep`, `oct`, `nov`, `dec`}
var ordinals = []string{`st`, `nd`, `rd`, `th`}

// yySymType is generated by goyacc
func (l *datetimeLexer) Lex(lval *yySymType) int {
	for {
		_, tok, lit := l.scanner.Scan()
		lval.string = lit

		if yyDebug == 3 {
			fmt.Printf("tok: %q, lit: %q\n", tok, lit)
		}

		if tok == token.EOF || (tok == token.SEMICOLON && lit == "\n") {
			lval.string = "$end"
			return -1
		}

		switch tok {

		case token.ILLEGAL:
			litl := strings.ToLower(lit)
			lval.string = litl

			switch litl {

			case "@":
				return AMP

			default:
				return ILLEGAL
			}

		case token.IDENT:
			litl := strings.ToLower(lit)
			lval.string = litl

			if tok == token.IDENT && len(lit) >= 3 {
				for i, month := range months {
					if litl[0:3] == month {
						lval.int = i + 1
						return MONTH
					}
				}
			}

			if tok == token.IDENT && len(lit) == 2 {
				for _, ord := range ordinals {
					if litl == ord {
						// Skip this by re-running.
						return l.Lex(lval)
					}
				}
			}

			switch litl {

			case "am":
				return AM
			case "calendar":
				return CALENDAR
			case "google":
				return GOOGLE
			case "ics":
				return ICS
			case "pm":
				return PM
			case "through":
				return THROUGH
			case "to":
				return TO

			default:
				return IDENT
			}

		case token.INT:
			i, err := strconv.Atoi(lit)
			if err != nil {
				panic(fmt.Errorf("can't convert string to int: %q", lit))
			}
			lval.int = i
			return INT

		case token.COLON:
			return COLON
		case token.COMMA:
			return l.Lex(lval)
		case token.QUO:
			return QUO
		case token.SEMICOLON:
			return SEMICOLON
		case token.SUB:
			return SUB

		default:
			return ILLEGAL
		}
	}
}

// 	// fmt.Printf("lexeme before: %q", lexeme)
//   // lexeme := strings.ToLower(l.s.TokenText())
// 	// fmt.Printf("lexeme before: %q", lexeme)

// 	// if isInt(lexeme) {
// 	// 	return NUMBER
// 	// }

//   switch lexeme {
// 	case ` `:
// 		return SPC
// 	case `january`, `february`, `march`, `april`, `may`, `june`, `july`, `august`, `september`, `october`, `november`, `december`,
// 		`jan`, `feb`, `mar`, `apr`, `jun`, `jul`, `aug`, `sep`, `oct`, `nov`, `dec`:
// 		return MONTH
// 	case "(":
//     return OPEN // generated by goyacc
//   case ")":
//     return CLOSE // generated by goyacc
//   case ",":
//     lval.op = andOp
//     return OP // generated by goyacc
//   case ";":
//     lval.op = orOp
//     return OP // generated by goyacc
//   default:
//     lval.label = lexeme
//     return LABEL // generated by goyacc
//   }
// }

// func isInt(s string) bool {
//     for _, c := range s {
//         if !unicode.IsDigit(c) {
//             return false
//         }
//     }
//     return true
// }
