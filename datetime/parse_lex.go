package datetime

import (
	"errors"
	"regexp"
	"strings"

	"go/scanner"
	"go/token"

	"github.com/findyourpaths/phil/glr"
	"github.com/microcosm-cc/bluemonday"
)

// datetimeLexer implements yyLexer interface for the parser generated by goyacc,
// and also GLR's Lexer interface.
type datetimeLexer struct {
	lval    *yySymType
	scanner scanner.Scanner
	err     error
	root    *DateTimeTZRanges
}

// Match a digit on one side and a letter on another. Used to separate `12pm`.
var boundaryRE1 = regexp.MustCompile(`([[:alpha:]])([[:^alpha:]])`)
var boundaryRE2 = regexp.MustCompile(`([[:^alpha:]])([[:alpha:]])`)

// var spacifyRE = regexp.MustCompile(`\s*\b(.|-)\b\s*`)
var spacifyRE = regexp.MustCompile(`(?:^|\s*\b)(.|-)(?:\b\s*|$)`)

func NewDatetimeLexer(input string) *datetimeLexer {
	// yyDebug = 3
	debugf("in before processing: %q\n", input)
	// input = daysRE.ReplaceAllString(input, ``)
	input = boundaryRE1.ReplaceAllString(input, `$1 $2`)
	input = boundaryRE2.ReplaceAllString(input, `$1 $2`)
	input = spacifyRE.ReplaceAllString(input, ` $1 `)
	// input = strings.TrimPrefix(input, "When ")
	// input = strings.TrimPrefix(input, "when ")
	input = strings.Replace(input, " ' ", " ", -1)
	input = CleanTextLine(input)
	// input = strings.Replace(input, " &#39; ", "\\'", -1)
	debugf("input after processing: %q\n", input)

	l := &datetimeLexer{
		lval: &yySymType{},
	}
	l.scanner = glr.NewLexerScanner(l, input)
	return l
}

var whitespacesRE = regexp.MustCompile(`\s+`)

func CleanTextLine(s string) string {
	r := bluemonday.StrictPolicy().AddSpaceWhenStrippingTag(true).Sanitize(s)
	r = strings.ReplaceAll(r, "\u00a0", " ")
	r = whitespacesRE.ReplaceAllString(r, " ")
	r = strings.TrimSpace(r)
	return r
}

func (l *datetimeLexer) NextToken(pos int) (string, string, bool) {
	val := l.Lex(l.lval)
	sym := l.lval.string
	if val >= 57343 {
		sym = yyToknames[val-57343]
	}
	// fmt.Printf("sym: %q, l.lval.string: %q, val: %d\n", sym, l.lval.string, val)
	return sym, l.lval.string, val >= 0
}

func (l *datetimeLexer) Error(msg string) {
	l.err = errors.New(msg)
}

// yySymType is generated by goyacc
func (l *datetimeLexer) Lex(lval *yySymType) int {
	for {
		_, tok, lit := l.scanner.Scan()
		features := ""
		if tok == token.ILLEGAL {
			features += " ILLEGAL"
		}
		if tok == token.IDENT {
			features += " IDENT"
		}
		debugf("scanned literal: %q as token: %q%s\n", lit, tok, features)

		// Skip whitespace and semicolons
		if tok == token.SEMICOLON {
			continue
		}
		if tok == token.EOF {
			lval.string = "$end"
			return -1
		}

		lval.string = lit
		if lit == "" {
			lval.string = tok.String()
		}
		// fmt.Printf("lval.string: %#v\n", lval.string)

		switch tok {

		case token.ILLEGAL:
			litl := strings.ToLower(lit)
			switch litl {
			case "@":
				return AMP

			case "–":
				return SUB

			case "—":
				return SUB

			default:
				return ILLEGAL
			}

		case token.IDENT:
			lowLit := strings.ToLower(lit)
			switch lowLit {
			case "a":
				return A
			case "am":
				return AM
			case "and":
				return AND
			case "at":
				return AT
			case "beginning":
				return BEGINNING
			case "calendar":
				return CALENDAR
			case "date":
				return DATE
			case "dates":
				return DATES
			case "from":
				return FROM
			case "google":
				return GOOGLE
			case "ics":
				return ICS
			case "in":
				return IN
			case "midnight":
				return TIME_NAME
			case "noon":
				return TIME_NAME
			case "of":
				return OF
			case "on":
				return ON
			case "part":
				return PART
			case "p":
				return P
			case "pm":
				return PM
			case "save":
				return SAVE
			case "through":
				return THROUGH
			case "t":
				return T
			case "th":
				return TH
			case "the":
				return THE
			case "till":
				return TILL
			case "time":
				return TIME
			case "to":
				return TO
			case "until":
				return UNTIL
			case "when":
				return WHEN
			case "z":
				return Z

			default:
				if _, found := monthsByNames[lowLit]; found {
					return MONTH_NAME
				}

				if _, found := weekdaysByNames[lowLit]; found {
					return WEEKDAY_NAME
				}

				if ordinals[lowLit] {
					return ORD_IND
				}

				upLit := strings.ToUpper(lit)
				// tz, err := tzTimezone.GetTzAbbreviationInfo(upLit)
				// fmt.Println("upLit", upLit, "tz", tz, "err", err)
				if tz, _ := timezoneTZ.GetTzAbbreviationInfo(upLit); tz != nil {
					return TIME_ZONE_ABBREV
				}
				if tz, _ := timezoneTZ.GetTzInfo(upLit); tz != nil {
					return TIME_ZONE
				}

				return IDENT
			}

		case token.INT:
			if len(lit) == 4 &&
				(strings.HasPrefix(lit, "17") ||
					strings.HasPrefix(lit, "18") ||
					strings.HasPrefix(lit, "19") ||
					strings.HasPrefix(lit, "20") ||
					strings.HasPrefix(lit, "21")) {
				return YEAR
			}
			return INT

		case token.ADD:
			return ADD
		case token.COLON:
			return COLON
		case token.COMMA:
			return COMMA
		case token.DEC:
			return DEC
		case token.LPAREN:
			return LPAREN
		case token.PERIOD:
			return PERIOD
		case token.QUO:
			return QUO
		case token.RPAREN:
			return RPAREN
		case token.SEMICOLON:
			return SEMICOLON
		case token.SUB:
			return SUB
		default:
			return ILLEGAL
		}
	}
}
